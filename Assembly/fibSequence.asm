.ORIG x3000

;;;;;;;;;;;;;;;;;
; MAIN FUNCITON ;
;;;;;;;;;;;;;;;;;
MAIN
LD R6, STACK_PTR ; LOAD STACK POINTER (R6 = x5013)
ADD R6, R6, #-1 ; GO BACK 1 (R6 = x5012)
ADD R5, R6, #0 ; POINT LOCAL VARIABLE
LEA R4, GLOBAL_VARS ; GLOBAL VARIABLES
LEA R0, PROMPT0
PUTS ; PRINT
GETC ; USER INPUT
OUT ; ECHO USER INPUT
LD R1, ASCII_NUM ; LOAD ASCII VALUE OFFSET
ADD R0, R0, R1 ; SUBTRACT OFFSET
ADD R1, R0, #0 ; COPY REGISTER 0 TO 1
STR R0, R6, #0 ; STORE DECIMAL INPUT 
ADD R6, R6, #-1 ; GO BACK 1 (R6 = x5011)
JSR FIB ; CALL SUBROUTINE

LDR R2, R5, #-1 ; load return value
ADD R6, R6, #1 ; POP INPUT
LEA R0, PROMPT1
PUTS
ADD R0, R1, #0 ; COPY REGISTER 1 TO 0
LD R1, ASCII_NUM ; LOAD ASCII OFFSET
NOT R1, R1 ; NEGATE 
ADD R1, R1, #1 ; ADD 1
ADD R0, R0, R1 ; CONVERT ASCII
OUT
LEA R0, PROMPT2
PUTS
ADD R0, R2, #0
JSR OUTPUT

ADD R6, R6, #1
BRnzp MAIN
HALT

GLOBAL_VARS					;	Your global variables start here
PROMPT0 		.STRINGZ	"\nPlease enter a number n: "; first prompt to print
STACK_PTR		.FILL x5013	;	STACK_PTR is a pointer to the bottom of the stack	(x5013)
ASCII_NUM		.FILL #-48	;
PROMPT1 		.STRINGZ	"\nF(";	 second prompt
PROMPT2 		.STRINGZ	") = ";  second prompt
PROMPT3			.STRINGZ	"\n"


;;;;;;;;;;;;;;;;;;
; FIB SUBROUTINE ;
;;;;;;;;;;;;;;;;;;
FIB

; ADD R6, R6, #-1

ADD R6, R6, #-1 ; GO BACK 1 (R6 = x5010)
STR R7, R6, #0 ; STORE RETURN ADDRESS ON STACK

ADD R6, R6, #-1 ; GO BACK 1 (R6 = x500F)
STR R5, R6, #0 ; STORE R5 ON STACK

ADD R6, R6, #-1 ; GO BACK 1 (R6 = x500E)
STR R3, R6, #0 ; STORE R3 ON STACK

ADD R6, R6, #-1 ; GO BACK 1 (R6 = x500D)
STR R2, R6, #0 ; STORE R2 ON STACK

ADD R6, R6, #-1 ; GO BACK 1 (R6 = x500C)
STR R1, R6, #0 ; STORE R1 ON STACK

ADD R6, R6, #-1 ; GO BACK 1 (R6 = x500B)
STR R0, R6, #0 ; STORE R0 ON STACK

ADD R6, R6, #-1 ; GO BACK 1 (R6 = x500A)

ADD R5, R6, #0 ; MAKE R5 POINT TO R6 (R5 = x500A)
;;;;;;;;;;;;

LDR R0, R5, #8 ; LOAD INPUT FROM STACK
BRz END_ALL_CASES
ADD R1, R0, #-1 ;  SUBTRACT 1 (n-1)
BRz END_ALL_CASES ; CHECK IF 0

;;;;;;;;;;;;;;;;;
; CALCULATE N-1 ;
;;;;;;;;;;;;;;;;;
ADD R0, R0, #-1
STR R0, R6, #0 ; STORE INPUT
ADD R6, R6, #-1 ; GO BACK 1 (R6 = x5009)
JSR FIB ; CALL FIB
LDR R1, R6, #0 ; LOAD VALUE FROM STACK
ADD R6, R6, #1 ; POP

;;;;;;;;;;;;;;;;;
; CALCULATE N-2 ;
;;;;;;;;;;;;;;;;;

ADD R0, R0, #-1
STR R0, R6, #0
ADD R6, R6, #-1
JSR FIB ; CALL FIB
LDR R2, R6, #0
ADD R6, R6, #1 ; POP

ADD R0, R1, R2 ; ADD REGISTERS


END_ALL_CASES

    STR R0, R5, #7 ; STORE RETURN ADDRESS
    ADD R6, R6, #1 ; GO UP 1 (R6 = x500B)
    LDR R0, R6, #0 ; RESTORE R0

    ADD R6, R6, #1 ; GO UP 1 (R6 = x500C)
    LDR R1, R6, #0 ; RESTORE R1

    ADD R6, R6, #1 ; GO UP 1 (R6 = x500D)
    LDR R2, R6, #0 ; RESTORE R2

    ADD R6, R6, #1 ; GO UP 1 (R6 = x500E)
    LDR R3, R6, #0 ; RESTORE R3

    ADD R6, R6, #1 ; GO UP 1 (R6 = x500F)
    LDR R5, R6, #0 ; RESTORE R5

    ADD R6, R6, #1 ; GO UP 1 (R6 = x5010)
    LDR R7, R6, #0 ; RESTORE R7

    ADD R6, R6, #1 ; POP (R6 = x5011)

RET

OUTPUT

ST R7, STORE_R7 ;STORE R7
LD R1, OFFSET
LEA R2, RESULT ; LD EFFECTIVE ADDRESS OF REULT

AND R3, R3, #0 ; COUNTER
LD R4, NEG_TEN


SUB_TEN
ADD R0, R0, R4
BRn NEG
ADD R3, R3, #1
BRnzp SUB_TEN

NEG
LD R5, POS_TEN
ADD R0, R5, R0
ADD R3, R3, R1
STR R3, R2, #0
ADD R0, R0, R1
STR R0, R2, #1
AND R0, R0, #0
STR R0, R2, #2

LEA R0, RESULT
PUTS

LD R7, STORE_R7 ; RESTORE ADDRESS

RET

STORE_R7 .BLKW #1
OFFSET .FILL  #48
RESULT .BLKW #3
NEG_TEN .FILL #-10
POS_TEN .FILL #10


.END
